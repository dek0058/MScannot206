---@description "게임 서버에 대한 공통적인 처리를 담당하는 로직입니다."
@Logic
script GameServerLogic extends Logic
	
	---@description "서버 상태: 초기화 중"
	property string State_Initializing = "Initializing"

	---@description "서버 상태: 실행 중"
	property string State_Running = "Running"

	@ExecSpace("ServerOnly")
	method void OnBeginPlay()
		-- 작업 큐: table
		self._T["Tasks"] = {}
		
		-- 작업 대기 카운트: table
		self._T["Waits"] = {}
		
		-- 유저 맵 진입 기록: table<uid, string>
		self._T["UserEnteredMaps"] = {}
		
		self._T["DynamicMapNames"] = {}

		self:OnInit()
	end
	
	@ExecSpace("ServerOnly")
	method void OnInit()
		local init =
		_ChannelLogic:IsInit()
		or _GameTableLogic:IsInit()
		
		if init == true then
			self._T["init"] = init
			return
		end
		
		_TimerService:SetTimerOnce(function()
			self:OnInit()
		end, 1.0)
	end
	
	---@description "특정 유저에게 서버 상태를 클라이언트에게 알립니다."
	@ExecSpace("Server")
	method void FetchServerState(string uid)
		if uid ~= senderUserId then
			return
		end

		if self._T["init"] == nil then
			self:SendServerState(self.State_Initializing, uid)
			return
		end

		if self._T["init"] == false then
			self:SendServerState(self.State_Initializing, uid)
			return
		end

		self:SendServerState(self.State_Running, uid)
	end

	---@description "서버 상태를 전파합니다."
	@ExecSpace("Client")
	method void SendServerState(string state)
		local e = ServerStateEvent()
		e.state = state
		self:SendEvent(e)
	end
	
	---@description "특정 유저를 서버에서 강제 퇴장시킵니다."
	@ExecSpace("Server")
	method void Kick(string uid, string reason, string kickReason)
		if uid ~= senderUserId then
			return
		end

		log_warning("사용자 강제 퇴장: " .. uid .. ", 이유: " .. reason)
		_UserService:KickUser(uid, KickReason.CastFrom(kickReason))
	end
	
	---@description "서버에서 특정 유저를 강제 퇴장시킵니다."
	@ExecSpace("ServerOnly")
	method void KickByServer(string uid, string reason, string kickReason)
		log_warning("사용자 강제 퇴장: " .. uid .. ", 이유: " .. reason)
		_UserService:KickUser(uid, KickReason.CastFrom(kickReason))
	end
	
	---@description "작업을 큐에 추가합니다."
	@ExecSpace("ServerOnly")
	method void EnqueueTask(table task)
		if task == nil then
			log_error("task is null")
		end
		
		if task["event"] == nil then
			log_error("task에서 event 타입을 찾을 수 없습니다.")
			return
		end
		
		if _UtilLogic:IsNilorEmptyString(task["event"]) then
			log_error("task의 event 타입이 비어있습니다.")
			return
		end
		
		if task["callback"] == nil then
			log_error("task에서 callback 함수를 찾을 수 없습니다.")
			return
		end
		
		---@type table
		local tasks = self._T["Tasks"]
		
		---@type table
		local waits = self._T["Waits"]
		
		---@type string
		local eventType = task["event"]
		if tasks[eventType] == nil then
			tasks[eventType] = {}
		end
		table.insert(tasks[eventType], task)
		
		if waits[eventType] == nil then
			waits[eventType] = 1
		else
			waits[eventType] += 1
		end
	end
	
	---@description "작업을 큐에서 꺼냅니다."
	@ExecSpace("ServerOnly")
	method table DequeueTask(string eventType)
		if _UtilLogic:IsNilorEmptyString(eventType) then
			log_error("eventType is null or empty")
			return {}
		end
		
		---@type table
		local tasks = self._T["Tasks"]
		
		---@type table
		local waits = self._T["Waits"]
		
		if tasks[eventType] == nil then
			return {}
		end
		
		local cnt = waits[eventType]
		if cnt == nil or cnt <= 0 then
			return {}
		end
		
		local task = table.remove(tasks[eventType], 1)
		waits[eventType] = cnt - 1
		
		return task
	end

	---@description "유저가 맵에 입장시 이벤트를 처리합니다."
	@ExecSpace("Server")
	method void EnterMap(string uid, string mapName)
		if uid ~= senderUserId then
			return
		end

		local userPlayerCom = _UserProxy:GetUserLocalPlayerComponentByServer(uid)
		if userPlayerCom == nil then
			_GameServerLogic:KickByServer(_UserProxy:GetUid(), "로컬 플레이어를 찾을 수 없습니다.", "WorldError")
			return
		end

		---@type table<string, string>
		local userEnteredMaps = self._T["UserEnteredMaps"]
		if userEnteredMaps ~= nil then
			-- 이미 같은 맵에 진입한 경우 무시
			if userEnteredMaps[uid] == mapName then
				return
			end
		end
		userEnteredMaps[uid] = mapName
		userPlayerCom:SetEnable(false)

		---@type table
		local waits = self._T["Waits"]
		
		local callback = function()
			local mapEntity = _EntityService:GetEntityByPath("/maps/" .. mapName)
			if mapEntity ~= nil then
				local e = MapEnterEvent()
				e.mapName = mapName
				e.uid = uid
				mapEntity:SendEvent(e)
			end
		end
		
		if waits["EnterMap"] ~= nil then
			---@type integer
			local cnt = waits["EnterMap"]
			if cnt > 0 then
				local task = {}
				task["event"] = "EnterMap"
				task["callback"] = callback
				self:EnqueueTask(task)
				return
			end
		end
		
		callback()
	end

	---@description "유저가 맵에서 퇴장시 이벤트를 처리합니다."
	@ExecSpace("Server")
	method void LeaveMap(string uid, string mapName)
		if uid ~= senderUserId then
			return
		end

		local mapEntity = _EntityService:GetEntityByPath("/maps/" .. mapName)
		if mapEntity ~= nil then
			local e = MapLeaveEvent()
			e.mapName = mapName
			e.uid = uid
			mapEntity:SendEvent(e)
		end
		
	end
	
	---@description "유저를 특정 맵으로 이동시킵니다."
	@ExecSpace("ServerOnly")
	method void TeleportToMapForUser(string uid, string mapName)
		local userEntity = _UserService:GetUserEntityByUserId(uid)
		if userEntity == nil then
			log_error("유저 Entity를 찾을 수 없습니다: " .. uid)
			return
		end

		_TeleportService:TeleportToMapPosition(userEntity, Vector3.zero, mapName)
	end

	---@description "유저가 다른 맵으로 이동을 요청 합니다."
	@ExecSpace("Server")
	method void TeleportToBanishMapForUser(string uid)
		if uid ~= senderUserId then
			return
		end
		
		self:TeleportToMapForUser(uid, "BanishMap")
	end
	
	---@description "유저를 다른 월드 인스턴스로 워프시킵니다."
	@ExecSpace("Server")
	method void WrapToWorldInstance(string uid, string id)
		if uid ~= senderUserId then
			return
		end
		
		if _WorldInstanceService.WorldInstanceId == id then
			return
		end
		
		local userEntity = _UserService:GetUserEntityByUserId(uid)
		if userEntity == nil then
			log_error("유저 Entity를 찾을 수 없습니다: " .. uid)
			return
		end
		
		---@type table<string, string>
		local userEnteredMaps = self._T["UserEnteredMaps"]
		
		---@type UserWarpRecord
		local warpRecord = UserWarpRecord()
		warpRecord.loggedin = _UserLogic:IsUserExists(uid)
		warpRecord.mapName = userEnteredMaps[uid]
		warpRecord.location = userEntity.TransformComponent.Position
		
		_TeleportService:WarpUserToWorldInstanceAsync(
			uid, id, warpRecord:ToJson(), function(success)
				if success == false then
					log_warning("월드 인스턴스 워프에 실패했습니다: " .. uid)
					return
				end
			end
		)
	end

	---@description "동적 맵을 생성합니다"
	---@param srcMapName string "생성 할 기반이 될 맵 이름"
	---@param createMapName string "생성 될 맵 이름"
	---@return ErrorType "맵 생성 결과를 반환합니다. 성공 시 에러가 없습니다"
	@ExecSpace("ServerOnly")
	method ErrorType CreateDynamicMap(string srcMapName, string createMapName)
		local err = ErrorType()

		local result = _DynamicMapService:CreateDynamicMap(srcMapName, createMapName)
		if result ~= DynamicMapResultCode.Success then
			err:AddError("동적 맵 생성에 실패했습니다. [srcMapName:" .. srcMapName .. "][createMapName:" .. createMapName .. "][errorCode:" .. tostring(result) .. "]")
			return err
		end
		
		local dynamicMapNames = self._T["DynamicMapNames"]
		dynamicMapNames[createMapName] = true
		
		return err
	end

	---@description "동적 맵을 파괴합니다"
	---@param mapName string "파괴할 맵 이름"
	---@return ErrorType "맵 파괴 결과를 반환합니다. 성공 시 에러가 없습니다"
	@ExecSpace("ServerOnly")
	method ErrorType DestroyDynamicMap(string mapName)
		local err = ErrorType()
		local result = _DynamicMapService:DestroyDynamicMap(mapName)
		if result ~= DynamicMapResultCode.Success then
			err:AddError("동적 맵 파괴에 실패했습니다. [mapName:" .. mapName .. "][errorCode:" .. tostring(result) .. "]")
			return err
		end
		
		local dynamicMapNames = self._T["DynamicMapNames"]
		dynamicMapNames[mapName] = nil

		return err
	end

	---@description "동적 맵이 존재하는지 확인합니다"
	---@param mapName string "확인할 맵 이름"
	---@return boolean "동적 맵 존재 여부를 반환합니다"
	@ExecSpace("ServerOnly")
	method boolean IsExistsDynamicMap(string mapName)
		local dynamicMapNames = self._T["DynamicMapNames"]
		return dynamicMapNames[mapName] == true
	end
	
	@ExecSpace("ServerOnly")
	@EventSender("Service", "UserService")
	handler HandleUserLeaveEvent(UserLeaveEvent e)
		---@type table<string, string>
		local userEnteredMaps = self._T["UserEnteredMaps"]
		
		if userEnteredMaps[e.UserId] ~= nil then
			userEnteredMaps[e.UserId] = nil
		end
	end
	
end