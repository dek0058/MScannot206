---@description "캐릭터에 대한 처리 및 관리를 담당하는 로직입니다"
@Logic
script CharacterLogic extends Logic

	---@description "캐릭터 데이터 저장소 키"
	readonly property string Key_Character = "char"

	---@description "캐릭터 생성 API"
	readonly property string Api_CreateCharacter = "user/character/create"

	---@description "캐릭터 생성 요청 대기 시간"
	readonly property integer CreateCharacterRequestTimeSec = 1

	---@description "캐릭터 생성 요청 최대 처리 개수"
	readonly property integer MaxCreateCharacterRequestPerFlush = 10

	---@description "캐릭터 삭제 API"
	readonly property string Api_DeleteCharacter = "user/character/delete"

	---@description "캐릭터 삭제 요청 대기 시간"
	readonly property integer DeleteCharacterRequestTimeSec = 1

	---@description "캐릭터 삭제 요청 최대 처리 개수"
	readonly property integer MaxDeleteCharacterRequestPerFlush = 10

	@ExecSpace("ServerOnly")
	method void OnBeginPlay()
		-- 캐릭터 생성 요청 대기열 초기화
		self._T["CreateCharacterRequestQueue"] = UserRequestQueue()

		-- 캐릭터 삭제 요청 대기열 초기화
		self._T["DeleteCharacterRequestQueue"] = UserRequestQueue()
	end

	---@description "캐릭터 데이터 저장소 키를 반환합니다"
	---@param slot integer "캐릭터 슬롯 번호"
	---@return string "캐릭터 데이터 저장소 키"
	@ExecSpace("ServerOnly")
	method string GetCharacterStorageKey(integer slot)
		return self.Key_Character .. ":" .. slot
	end

	---@description "캐릭터를 생성합니다. 생성된 캐릭터를 반환합니다"
	---@param uid string "캐릭터를 생성할 유저의 고유 아이디"
	---@param entity CharacterEntity "생성할 캐릭터 정보"
	---@param equips table<CharacterEquipEntity> "생성할 캐릭터의 장비 정보"
	---@return Character "생성된 캐릭터 정보"
	@ExecSpace("ServerOnly")
	method Character CreateCharacter(string uid, CharacterEntity entity, table<CharacterEquipEntity> equips)
		local character = Character()
		if character == nil then
			log_error("캐릭터 생성에 실패했습니다")
			return nil
		end

		local userStorageCom = _UserProxy:GetUserStorageComponentByServer(uid)
		if userStorageCom == nil then
			log_error("UserStorageComponent is nil")
			return nil
		end

		character.uid = uid
		character.slot = entity.slot
		character.name = entity.name
		character.gender = entity.gender
		for _, equip in ipairs(equips) do
			if equip.type == _CharacterDef.CharacterEquipType_None then
				log_warning("캐릭터 장비 타입이 None입니다. equip index: " .. tostring(equip.index))
				continue
			end

			local record = _GameTableLogic.characterEquipItemTable:GetRecord(equip.index)
			if record == nil then
				log_error("캐릭터 장비 아이템 레코드가 없습니다. equip index: " .. tostring(equip.index))
				continue
			end

			 local newEquipItem = _ItemLogic:CreateItem(equip.index)
			 if newEquipItem == nil then
			 	log_error("캐릭터 장비 아이템 생성에 실패했습니다. equip index: " .. tostring(equip.index))
			 	continue
			 end

			 newEquipItem.count = 1
			 newEquipItem.bound = record.Bound

			 local err = ErrorType()
			 err = _InventoryLogic:AddItemToCharacter(character, newEquipItem)
			 if err:IsError() then
				err:PrintErrors()
			 	continue
			 end

			 err = self:EquipItem(character, newEquipItem)
			 if err:IsError() then
				err:PrintErrors()
				continue
			 end
		end

		userStorageCom:SetCharacter(character)

		return character
	end

	---@description "캐릭터에 장비를 착용합니다"
	---@param character Character "장비를 착용할 캐릭터 정보"
	---@param item ItemEntity "착용할 장비 정보"
	---@return ErrorType "장비 착용 결과 에러 정보"
	@ExecSpace("ServerOnly")
	method ErrorType EquipItem(Character character, ItemEntity item)
		local err = ErrorType()

		if character == nil then
			err:AddError("Character is nil")
			return err
		end

		if item == nil then
			err:AddError("ItemEntity is nil")
			return err
		end

		local itemRecord = _GameTableLogic.itemTable:GetRecord(item.index)
		if itemRecord == nil then
			err:AddError("아이템 레코드가 없습니다. item index: " .. tostring(item.index))
			return err
		end

		local equipRecord = _GameTableLogic.characterEquipItemTable:GetRecord(item.index)
		if equipRecord == nil then
			err:AddError("캐릭터 장비 아이템 레코드가 없습니다. item index: " .. tostring(item.index))
			return err
		end

		if itemRecord.Category == _CharacterDef.CharacterEquipType_None then
			err:AddError("아이템이 장비 아이템이 아닙니다. item index: " .. tostring(item.index))
			return err
		end

		if character.gender == _CharacterDef.GenderType_Male then
			if equipRecord.Male == false then
				err:AddError("남성 캐릭터는 해당 장비를 착용할 수 없습니다. item index: " .. tostring(item.index))
				return err				
			end
		elseif character.gender == _CharacterDef.GenderType_Female then
			if equipRecord.Female == false then
				err:AddError("여성 캐릭터는 해당 장비를 착용할 수 없습니다. item index: " .. tostring(item.index))
				return err
			end
		else
			err:AddError("캐릭터 성별이 올바르지 않습니다. character gender: " .. tostring(character.gender))
			return err
		end

		local userStorageCom = _UserProxy:GetUserStorageComponentByServer(character.uid)
		if userStorageCom == nil then
			err:AddError("UserStorageComponent is nil")
			return err
		end

		character:EquipSlot(itemRecord.Category, item.id)
		userStorageCom:SetCharacter(character)

		return err
	end

	---@description "유저가 캐릭터 목록을 불러오도록 요청합니다"
	---@param uid string "유저 고유 아이디"
	@ExecSpace("Server")
	method void LoadCharacters(string uid)
		if uid ~= senderUserId then
			return
		end

		local userStorageCom = _UserProxy:GetUserStorageComponentByServer(uid)
		if userStorageCom == nil then
			log_error("UserStorageComponent is nil")
			local e = CharactersLoadEvent()
			e.errorCode = _ErrorLogic.USER_CHARACTER_LOAD_ERROR
			_UserProxy:SendEventToLocalPlayer(e, uid)
			return
		end

		local user = _UserLogic:GetUser(uid)
		if user == nil then
			local e = CharactersLoadEvent()
			e.errorCode = _ErrorLogic.USER_CHARACTER_LOAD_NEED_LOGIN_ERROR
			_UserProxy:SendEventToLocalPlayer(e, uid)
			return
		end

		if user.userEntity == nil then
			local e = CharactersLoadEvent()
			e.errorCode = _ErrorLogic.USER_CHARACTER_LOAD_ERROR
			_UserProxy:SendEventToLocalPlayer(e, uid)
			return
		end

		-- 캐릭터가 없다
		if user.userEntity.characters == nil then
			local e = CharactersLoadEvent()
			_UserProxy:SendEventToPlayer(e, uid)
			return
		end

		---@type table<DataStorageKeyInfo>
		local keys = {}
		for _, char in ipairs(user.userEntity.characters) do
			local key = DataStorageKeyInfo()
			key.Key = self:GetCharacterStorageKey(char.slot)
			key.Tag = self.Key_Character
			key.Version = _DefLogic.Version

			table.insert(keys, key)
		end

		-- 캐릭터 데이터가 하나도 없는 경우 바로 이벤트 전송
		if #keys == 0 then
			local e = CharactersLoadEvent()
			_UserProxy:SendEventToPlayer(e, uid)
			return
		end

		local userStorageData = _DataStorageService:GetUserDataStorage(uid)
		if userStorageData == nil then
			local e = CharactersLoadEvent()
			e.errorCode = _ErrorLogic.USER_CHARACTER_LOAD_ERROR
			_UserProxy:SendEventToLocalPlayer(e, uid)
			return
		end
		
		local errorCode, itemPages = userStorageData:BatchGetByInfoAndWait(keys)
		if errorCode ~= 0 then
			log_error("캐릭터 데이터 로드에 실패했습니다. error code: " .. tostring(errorCode))
			local e = CharactersLoadEvent()
			e.errorCode = _ErrorLogic.USER_CHARACTER_LOAD_ERROR
			_UserProxy:SendEventToLocalPlayer(e, uid)
			return
		end

		---@type table<Character>
		local loadedCharacters = {}
		while true do
			---@type table<DataStorageItem>
			local datas = itemPages:GetCurrentPageDatas()
			for _, data in ipairs(datas) do
				if _UtilLogic:IsNilorEmptyString(data.Value) then
					-- TODO: 삭제해야 할 데이터
					continue
				end
				local content = _HttpService:JSONDecode(data.Value)

				local loadedChar = Character():FromTable(content)
				table.insert(loadedCharacters, loadedChar)
			end

			if itemPages.IsLastPage == true then
				break
			end
			
			local loadResultCode = itemPages:LoadNextPageAndWait()
			if loadResultCode ~= 0 then
				break
			end
			
			itemPages:MoveToNextPageAndWait()
		end

		local inventories = _InventoryLogic:LoadCharacterInventories(uid, loadedCharacters)
		if inventories == nil then
			log_error("캐릭터 인벤토리 로드에 실패했습니다")
			local e = CharactersLoadEvent()
			e.errorCode = _ErrorLogic.USER_CHARACTER_LOAD_ERROR
			_UserProxy:SendEventToLocalPlayer(e, uid)
			return
		end

		userStorageCom:SetCharacters(loadedCharacters)
		userStorageCom:SetCharacterInventories(inventories)

		local e = CharactersLoadEvent()
		e.characters = loadedCharacters
		_UserProxy:SendEventToLocalPlayer(e, uid)
	end

	---@description "유저가 캐릭터 생성을 요청합니다"
	---@param uid string "유저 고유 아이디"
	---@param params CreateCharacterParams "캐릭터 생성 파라미터"
	@ExecSpace("Server")
	method void RequestCreateCharacter(string uid, CreateCharacterParams params)
		if uid ~= senderUserId then
			return
		end
		
		---@type UserRequestQueue
		local queue = self._T["CreateCharacterRequestQueue"]
		if queue == nil then
			log_error("CreateCharacterRequestQueue가 없습니다")
			local e = CreateCharacterEvent()
			e.errorCode = _ErrorLogic.USER_CREATE_CHARACTER_UNKNOWN_ERROR
			_UserProxy:SendEventToLocalPlayer(e, uid)
			return
		end

		if queue:IsExists(uid) == true then
			local e = CreateCharacterEvent()
			e.errorCode = _ErrorLogic.USER_CREATE_CHARACTER_ALREADY_REQUEST
			_UserProxy:SendEventToLocalPlayer(e, uid)
			return
		end

		local user = _UserLogic:GetUser(uid)
		if user == nil then
			local e = CreateCharacterEvent()
			e.errorCode = _ErrorLogic.USER_CREATE_CHARACTER_USER_NOT_FOUND
			_UserProxy:SendEventToLocalPlayer(e, uid)
			return
		end

		local ur = UserRequest()
		ur.uid = uid
		ur.request = {
			["uid"] = uid,
			["token"] = user.token,
			["params"] = params,
		}

		queue:AddRequest(ur)

		self:OnReserveCreateCharacter()
	end

	---@description "요청받은 캐릭터 생성 처리를 예약 합니다"
	@ExecSpace("ServerOnly")
	method void OnReserveCreateCharacter()
		if self._T["CreateCharacterTimerId"] ~= nil then
			_TimerService:ClearTimer(self._T["CreateCharacterTimerId"])
			self._T["CreateCharacterTimerId"] = nil
		end

		local callback = function()
			self:OnRequestCreateCharacter()
			self._T["CreateCharacterTimerId"] = nil

			---@type UserRequestQueue
			local queue = self._T["CreateCharacterRequestQueue"]
			if queue == nil then
				return
			end

			if queue:IsEmpty() == true then
				return
			end

			self:OnReserveCreateCharacter()
		end
		local timerId = _TimerService:SetTimerOnce(callback, self.CreateCharacterRequestTimeSec)
		if timerId == 0 then
			log_error("캐릭터 생성 요청 타이머 설정에 실패했습니다")

			--- 3초 대기 후 재시도
			_TimerService:SetTimerOnce(function()
				self:OnReserveCreateCharacter()
			end, 3.0)
			return
		end

		self._T["CreateCharacterTimerId"] = timerId
	end

	---@description "요청받은 캐릭터 생성을 처리합니다"
	@ExecSpace("ServerOnly")
	method void OnRequestCreateCharacter()
		---@type UserRequestQueue
		local queue = self._T["CreateCharacterRequestQueue"]

		if queue == nil then
			log_error("CreateCharacterRequestQueue가 없습니다")
			return
		end

		if queue:IsEmpty() == true then
			return
		end

		local requests = queue:PullRequests(self.MaxCreateCharacterRequestPerFlush)
		local requestsUids = {}
		local req = CreateCharacterRequest()

		for _, r in ipairs(requests) do
			local token = r.request["token"] or ""

			---@type CreateCharacterParams
			local params = r.request["params"] or nil

			if _UtilLogic:IsNilorEmptyString(token) == true or params == nil then
				local e = CreateCharacterEvent()
				e.errorCode = _ErrorLogic.USER_CREATE_CHARACTER_UNKNOWN_ERROR
				_UserProxy:SendEventToLocalPlayer(e, r.uid)
				continue
			end

			local info = UserCreateCharacterInfo()
			info.uid = r.uid
			info.token = token
			info.name = params.name
			info.slot = params.slot
			info.gender = params.gender

			table.insert(requestsUids, r.uid)
			table.insert(req.requests, info)
		end

		local content = {}
		if #requestsUids > 0 then
			content["uids"] = requestsUids
		end

		if #req.requests > 0 then
			content["body"] = req:ToTable()
		end

		local callback = function(response, request)
			---@type table<string>
			local uids = request["uids"]
			if uids == nil then
				return
			end

			local res = CreateCharacterResponse():FromTable(response)
			local passedUids = {}

			for _, r in ipairs(res.responses) do
				if _UtilLogic:IsNilorEmptyString(r.errorCode) == false then
					local e = CreateCharacterEvent()
					e.errorCode = r.errorCode
					_UserProxy:SendEventToLocalPlayer(e, r.uid)
					passedUids[r.uid] = true
					continue
				end

				if r.character == nil then
					continue
				end

				local user = _UserLogic:GetUser(r.uid)
				if user == nil then
					continue
				end

				table.insert(user.userEntity.characters, r.character)

				local newChar = self:CreateCharacter(r.uid, r.character, r.equips)
				local e = CreateCharacterEvent()
				e.character = newChar
				_UserProxy:SendEventToPlayer(e, r.uid)
				passedUids[r.uid] = true
			end

			for _, uid in pairs(uids) do
				if passedUids[uid] == nil then
					local e = CreateCharacterEvent()
					e.errorCode = _ErrorLogic.USER_CREATE_CHARACTER_UNKNOWN_ERROR
					_UserProxy:SendEventToLocalPlayer(e, uid)
				end
			end
		end

		local errorCallback = function(request)
			local uids = request["uids"]
			if uids == nil then
				return
			end

			for _, uid in pairs(uids) do
				local e = CreateCharacterEvent()
				e.errorCode = _ErrorLogic.USER_CREATE_CHARACTER_UNKNOWN_ERROR
				_UserProxy:SendEventToLocalPlayer(e, uid)
			end
		end

		_BackendLogic:PushRequest(_BackendLogic:CreateRequest(self.Api_CreateCharacter, content, callback, errorCallback))
	end

	---@description "유저가 캐릭터 삭제를 요청합니다"
	---@param uid string "유저 고유 아이디"
	---@param slot integer "삭제할 캐릭터 슬롯"
	@ExecSpace("Server")
	method void RequestDeleteCharacter(string uid, integer slot)
		if uid ~= senderUserId then
			return
		end
		
		---@type UserRequestQueue
		local queue = self._T["DeleteCharacterRequestQueue"]
		if queue == nil then
			log_error("DeleteCharacterRequestQueue가 없습니다")
			local e = DeleteCharacterEvent()
			e.errorCode = _ErrorLogic.USER_DELETE_CHARACTER_UNKNOWN_ERROR
			_UserProxy:SendEventToLocalPlayer(e, uid)
			return
		end

		if queue:IsExists(uid) == true then
			local e = DeleteCharacterEvent()
			e.errorCode = _ErrorLogic.USER_DELETE_CHARACTER_ALREADY_REQUEST
			_UserProxy:SendEventToLocalPlayer(e, uid)
			return
		end

		local ur = UserRequest()
		ur.uid = uid
		ur.request = {
			["uid"] = uid,
			["slot"] = slot,
		}

		queue:AddRequest(ur)

		self:OnReserveDeleteCharacter()
	end

	---@description "요청받은 캐릭터 삭제 처리를 예약 합니다"
	@ExecSpace("ServerOnly")
	method void OnReserveDeleteCharacter()
		if self._T["DeleteCharacterTimerId"] ~= nil then
			_TimerService:ClearTimer(self._T["DeleteCharacterTimerId"])
			self._T["DeleteCharacterTimerId"] = nil
		end

		local callback = function()
			self:OnRequestDeleteCharacter()
			self._T["DeleteCharacterTimerId"] = nil

			---@type UserRequestQueue
			local queue = self._T["DeleteCharacterRequestQueue"]
			if queue == nil then
				return
			end

			if queue:IsEmpty() == true then
				return
			end

			self:OnReserveDeleteCharacter()
		end
		local timerId = _TimerService:SetTimerOnce(callback, self.DeleteCharacterRequestTimeSec)
		if timerId == 0 then
			log_error("캐릭터 삭제 요청 타이머 설정에 실패했습니다")
			--- 3초 대기 후 재시도
			_TimerService:SetTimerOnce(function()
				self:OnReserveDeleteCharacter()
			end, 3.0)
			return
		end

		self._T["DeleteCharacterTimerId"] = timerId
	end

	---@description "요청받은 캐릭터 삭제를 처리합니다"
	@ExecSpace("ServerOnly")
	method void OnRequestDeleteCharacter()
		---@type UserRequestQueue
		local queue = self._T["DeleteCharacterRequestQueue"]

		if queue == nil then
			log_error("DeleteCharacterRequestQueue가 없습니다")
			return
		end

		if queue:IsEmpty() == true then
			return
		end

		local requests = queue:PullRequests(self.MaxDeleteCharacterRequestPerFlush)
		local requestUids = {}
		local req = DeleteCharacterRequest()

		for _, r in ipairs(requests) do
			local uid = r.request["uid"] or ""
			local slot = r.request["slot"] or 0

			if _UtilLogic:IsNilorEmptyString(uid) == true then
				local e = DeleteCharacterEvent()
				e.errorCode = _ErrorLogic.USER_DELETE_CHARACTER_UNKNOWN_ERROR
				_UserProxy:SendEventToLocalPlayer(e, uid)
				continue
			end

			local user = _UserLogic:GetUser(uid)
			if user == nil then
				local e = DeleteCharacterEvent()
				e.errorCode = _ErrorLogic.USER_DELETE_CHARACTER_USER_NOT_FOUND
				_UserProxy:SendEventToLocalPlayer(e, uid)
				continue
			end

			local info = UserDeleteCharacterInfo()
			info.uid = uid
			info.token = user.token
			info.slot = slot

			table.insert(requestUids, uid)
			table.insert(req.requests, info)
		end

		local content = {}
		if #requestUids > 0 then
			content["uids"] = requestUids
		end
		if #req.requests > 0 then
			content["body"] = req:ToTable()
		end

		local callback = function(response, request)
			---@type table<string>
			local uids = request["uids"]
			if uids == nil then
				return
			end

			local res = DeleteCharacterResponse():FromTable(response)
			local passedUids = {}

			for _, r in ipairs(res.responses) do
				if _UtilLogic:IsNilorEmptyString(r.errorCode) == false then
					local e = DeleteCharacterEvent()
					e.errorCode = r.errorCode
					_UserProxy:SendEventToLocalPlayer(e, r.uid)
					passedUids[r.uid] = true
					continue
				end

				local user = _UserLogic:GetUser(r.uid)
				if user == nil then
					continue
				end

				for i, character in ipairs(user.userEntity.characters) do
					if character.slot == r.slot then
						table.remove(user.userEntity.characters, i)
						break
					end
				end

				local e = DeleteCharacterEvent()
				e.slot = r.slot
				_UserProxy:SendEventToPlayer(e, r.uid)
				passedUids[r.uid] = true
			end

			for _, uid in pairs(uids) do
				if passedUids[uid] == nil then
					local e = DeleteCharacterEvent()
					e.errorCode = _ErrorLogic.USER_DELETE_CHARACTER_UNKNOWN_ERROR
					_UserProxy:SendEventToLocalPlayer(e, uid)
				end
			end
		end

		local errorCallback = function(request)
			local uids = request["uids"]
			if uids == nil then
				return
			end

			for _, uid in pairs(uids) do
				local e = DeleteCharacterEvent()
				e.errorCode = _ErrorLogic.USER_DELETE_CHARACTER_UNKNOWN_ERROR
				_UserProxy:SendEventToLocalPlayer(e, uid)
			end
		end

		_BackendLogic:PushRequest(_BackendLogic:CreateRequest(self.Api_DeleteCharacter, content, callback, errorCallback))
	end

end