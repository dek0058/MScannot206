@Logic
script CharacterLogic extends Logic

	property any createCharacterRequest = BatchRequest()

	property boolean isDoingCreateCharacter = false

	property any deleteCharacterRequest = BatchRequest()

	property boolean isDoingDeleteCharacter = false

	property table characters = {}

	@ExecSpace("ServerOnly")
	method string GetCharacterKey(integer slot)
		return "character_" .. tostring(slot)
	end

	@ExecSpace("ServerOnly")
	method Character NewCharacter(integer slot, string name)
		local character = Character()
		character.slot = slot
		character.name = name
		return character
	end

	@ExecSpace("ServerOnly")
	method Character ToCharacter(table data)
		local character = Character()
		character.slot = data["slot"]
		character.name = data["name"]
		return character
	end

	@ExecSpace("ServerOnly")
	method Character GetCharacter(integer slot)
		-- if self.characters[slot] == nil then
		-- 	return nil
		-- end
		-- return self.characters[slot]
		return nil
	end

	@ExecSpace("ServerOnly")
	method void SetCharacter(string uid, Character character)
		local userDataStorage = _DataStorageService:GetUserDataStorage(uid)
		if userDataStorage == nil then
			return
		end
		local key =	self:GetCharacterKey(character.slot)
		userDataStorage:SetAsync(key, _HttpService:JSONEncode(character:ToTable()), nil)
	end

	@ExecSpace("Server")
	method void LoadCharacters()
		local uid = senderUserId
		if _UserLogic.users[uid] == nil then
			log("로드하려는 사용자를 찾을 수 없습니다: " .. uid)
			_LoginLogic:NeedLogin(uid)
			return
		end
		
		---@type table
		local entry = _UserLogic.users[uid]
		if entry["user_entity"] == nil then
			_LoginLogic:NeedLogin(uid)
			return
		end
		
		---@type table
		local userEntity = entry["user_entity"]
		if userEntity["characters"] == nil then
			self:UserCharacterLoadComplete({}, uid)
			return
		end
		
		---@type table
		local characters = userEntity["characters"]
		local charactersKeys = {}
		local characterCaches = {}
		for _, ch in ipairs(characters) do
			if ch == nil then
				continue
			end
			
			if ch["slot"] == nil or ch["name"] == nil then
				continue
			end
			
			local chKey = self:GetCharacterKey(ch["slot"])
			table.insert(charactersKeys, chKey)
			table.insert(characterCaches, _CharacterLogic:NewCharacter(ch["slot"], ch["name"]))
		end
		
		---@type UserDataStorage
		local userDataStorage = _DataStorageService:GetUserDataStorage(uid)
		if userDataStorage == nil then
			_UserService:KickUser(uid, KickReason.ETC)
			return
		end
		
		userDataStorage:BatchGetAsync(charactersKeys, function(errorCode, keys, datas)
			if errorCode ~= 0 then
				_LoginLogic:NeedLogin(uid)
				return
			end
			
			---@type DataStorageItemPages
			local pages = datas
			local characterMap = {}
			while true do
				for _, data in ipairs(pages:GetCurrentPageDatas()) do
					local ch = _HttpService:JSONDecode(data.Value)
					if ch == nil then
						continue
					end
					
					if ch["slot"] == nil then
						continue
					end
					
					characterMap[ch["slot"]] = ch
				end
				
				if pages.IsLastPage == true then
					break
				end
				
				local loadResultCode = pages:LoadNextPageAndWait()
				if loadResultCode ~= 0 then
					break
				end
				
				pages:MoveToNextPageAndWait()
			end
			
			local params = {}
			for _, cache in ipairs(characterCaches) do
				---@type Character
				local ch = cache
				
				local slot = tostring(ch.slot)
				if characterMap[slot] ~= nil then
					local data = characterMap[slot]
					ch.slot = data["slot"]
					ch.name = data["name"]
					table.insert(params, ch)
				else
					table.insert(params, ch)
				end
			end
			
			self:UserCharacterLoadComplete(params, uid)
		end)
	end

	@ExecSpace("Server")
	method void RequestCreateCharacter(CreateCharacterParams params)
		local uid = senderUserId
		
		if params == nil then
			self:CreateCharacterFailure(_ErrorLogic.USER_CREATE_CHARACTER_UNKNOWN_ERROR, uid)
			return
		end
		
		local nameLen = utf8.len(params.name)
		if _UtilLogic:IsNilorEmptyString(params.name) or nameLen < _DefLogic.MinNicknameLength then
			self:CreateCharacterFailure(_ErrorLogic.USER_CREATE_CHARACTER_NAME_MIN_LENGTH_ERROR, uid)
			return
		elseif nameLen > _DefLogic.MaxNicknameLength then
			self:CreateCharacterFailure(_ErrorLogic.USER_CREATE_CHARACTER_NAME_MAX_LENGTH_ERROR, uid)
			return
		end
		
		if _UserLogic.users[uid] == nil then
			self:CreateCharacterFailure(_ErrorLogic.USER_CREATE_CHARACTER_USER_NOT_FOUND, uid)
			return
		end
		local user = _UserLogic.users[uid]
		
		for _, pendingUid in pairs(self.createCharacterRequest:GetPendingRequests()) do
			if pendingUid == uid then
				-- 이미 생성 요청을 한 유저
				self:CreateCharacterFailure(_ErrorLogic.USER_CREATE_CHARACTER_ALREADY_REQUEST, uid)
				return
			end
		end
		
		params.uid = uid
		params.token = user["token"]
		
		self.createCharacterRequest:AddRequest(params)
		self:SendEvent(CreateCharacterEvent())
	end

	@ExecSpace("ServerOnly")
	method void OnRequestCreateCharacter()
		self:OnRequestCreateCharacter_Doing()
		self.isDoingCreateCharacter = false
		
		-- 추가적인 생성 요청이 있었는지 확인
		if self.createCharacterRequest:HasPendingRequests() == true then
			self:SendEvent(CreateCharacterEvent())
		end
	end

	@ExecSpace("ServerOnly")
	method void OnRequestCreateCharacter_Doing()
		local headers = {
			["Content-Type"] = "application/json"
		}
		
		local content = {
			["requests"] = {}
		}
		
		local requests = {}
		
		for _, entry in pairs(self.createCharacterRequest:GetPendingRequests()) do
			---@type CreateCharacterParams
			local params = entry
			table.insert(content["requests"], {
				["uid"] = params.uid,
				["token"] = params.token,
				["slot"] = params.slot,
				["name"] = params.name
			})
		
			requests[params.uid] = params.name
		end
		
		local contentJson = _HttpService:JSONEncode(content)
		local requestTime = _UtilLogic.ServerElapsedSeconds
		local response = _HttpService:RequestAndWait(
			_DefLogic.BackendUrl .. "/user/character/create",
			"POST", contentJson, headers
		)
		self:OnResponseCreateCharacter(response, requests)
		
		self.createCharacterRequest:ClearProcessedRequests()
		self.createCharacterRequest:FlushRequests()
		
		-- 추가 요청이 존재하고 생성 Delay 시간을 초과했다면 즉시 재실행
		if self.createCharacterRequest:HasPendingRequests() == true then
			local responseTime = _UtilLogic.ServerElapsedSeconds
			local diff = responseTime - requestTime
			if diff >= _DefLogic.CreateCharacterRequestTimeSec then
				self:OnRequestCreateCharacter_Doing()
			end
		end
	end

	@ExecSpace("ServerOnly")
	method void OnResponseCreateCharacter(string response, table requests)
		if _UtilLogic:IsNilorEmptyString(response) then
			for uid, name in pairs(requests) do
				self:CreateCharacterFailure(_ErrorLogic.USER_CREATE_CHARACTER_UNKNOWN_ERROR, uid)
			end
			return
		end
		
		local content = _HttpService:JSONDecode(response)
		if content["responses"] == nil then
			for uid, name in pairs(requests) do
				self:CreateCharacterFailure(_ErrorLogic.USER_CREATE_CHARACTER_UNKNOWN_ERROR, uid)
			end
			return
		end
		
		local responses = content["responses"]
		local doneUids = {}
		for _, res in ipairs(responses) do
			if res["uid"] == nil then
				continue
			end
		
			---@type string
			local uid = res["uid"]
		
			if res["error_code"] ~= nil then
				doneUids[uid] = {
					["result"] = res["error_code"]
				}
				continue
			end
		
			if res["character"] == nil then
				doneUids[uid] = {
					["result"] = _ErrorLogic.USER_CREATE_CHARACTER_UNKNOWN_ERROR
				}
				continue
			end
		
			local character = res["character"]
			local newCharacter = _CharacterLogic:ToCharacter(character)
		
			doneUids[uid] = {
				["result"] = "SUCCESS",
				["character"] = newCharacter
			}
			-- 게임DB에 저장
			self:SetCharacter(uid, newCharacter)
		end
		
		for uid, name in pairs(requests) do
			if doneUids[uid] == nil then
				self:CreateCharacterFailure(_ErrorLogic.USER_CREATE_CHARACTER_UNKNOWN_ERROR, uid)
			else
				local result = doneUids[uid]
				if result["result"] == nil then
					self:CreateCharacterFailure(_ErrorLogic.USER_CREATE_CHARACTER_UNKNOWN_ERROR, uid)
				elseif result["result"] == "SUCCESS" then
					self:CreateCharacterComplete(result["character"], uid)
				else
					self:CreateCharacterFailure(result["result"], uid)
				end
			end
		end
	end

	@ExecSpace("Server")
	method void RequestDeleteCharacter(integer slot)
		local uid = senderUserId
		
		if slot <= 0 or slot > _DefLogic.MaxCharacterSlot then
			self:DeleteCharacterFailure(_ErrorLogic.USER_DELETE_CHARACTER_SLOT_INVALID_ERROR, uid)
			return
		end
		
		if _UserLogic.users[uid] == nil then
			self:DeleteCharacterFailure(_ErrorLogic.USER_DELETE_CHARACTER_USER_NOT_FOUND, uid)
			return
		end
		local user = _UserLogic.users[uid]
		
		for _, pendingUid in pairs(self.deleteCharacterRequest:GetPendingRequests()) do
			if pendingUid == uid then
				-- 이미 삭제 요청을 한 유저
				self:DeleteCharacterFailure(_ErrorLogic.USER_DELETE_CHARACTER_ALREADY_REQUEST, uid)
				return
			end
		end
		
		local params = DeleteCharacterParams()
		params.uid = uid
		params.token = user["token"]
		params.slot = slot
		
		self.deleteCharacterRequest:AddRequest(params)
		self:SendEvent(DeleteCharacterEvent())
	end

	@ExecSpace("ServerOnly")
	method void OnRequestDeleteCharacter()
		self:OnRequestDeleteCharacter_Doing()
		self.isDoingDeleteCharacter = false
		
		-- 추가적인 삭제 요청이 있었는지 확인
		if self.deleteCharacterRequest:HasPendingRequests() == true then
			self:SendEvent(DeleteCharacterEvent())
		end
	end

	@ExecSpace("ServerOnly")
	method void OnRequestDeleteCharacter_Doing()
		local headers = {
			["Content-Type"] = "application/json"
		}
		
		local content = {
			["requests"] = {}
		}
		
		local requests = {}
		for _, entry in pairs(self.deleteCharacterRequest:GetPendingRequests()) do
			---@type DeleteCharacterParams
			local params = entry
		
			table.insert(content["requests"], {
				["uid"] = params.uid,
				["token"] = params.token,
				["slot"] = params.slot
			})
		
			requests[params.uid] = params.slot
		end
		
		local contentJson = _HttpService:JSONEncode(content)
		local requestTime = _UtilLogic.ServerElapsedSeconds
		local response = _HttpService:RequestAndWait(
			_DefLogic.BackendUrl .. "/user/character/delete",
			"POST", contentJson, headers
		)
		self:OnResponseDeleteCharacter(response, requests)
		
		self.deleteCharacterRequest:ClearProcessedRequests()
		self.deleteCharacterRequest:FlushRequests()
		
		-- 추가 요청이 존재하고 삭제 Delay 시간을 초과했다면 즉시 재실행
		if self.deleteCharacterRequest:HasPendingRequests() == true then
			local responseTime = _UtilLogic.ServerElapsedSeconds
			local diff = responseTime - requestTime
			if diff >= _DefLogic.DeleteCharacterRequestTimeSec then
				self:OnRequestDeleteCharacter_Doing()
			end
		end
	end

	@ExecSpace("ServerOnly")
	method void OnResponseDeleteCharacter(string response, table requests)
		if _UtilLogic:IsNilorEmptyString(response) then
			for uid, slot in pairs(requests) do
				self:DeleteCharacterFailure(_ErrorLogic.USER_DELETE_CHARACTER_UNKNOWN_ERROR, uid)
			end
			return
		end
		
		local content = _HttpService:JSONDecode(response)
		if content["responses"] == nil then
			for uid, slot in pairs(requests) do
				self:DeleteCharacterFailure(_ErrorLogic.USER_DELETE_CHARACTER_UNKNOWN_ERROR, uid)
			end
			return
		end
		
		local responses = content["responses"]
		local doneUids = {}
		for _, res in ipairs(responses) do
			if res["uid"] == nil then
				continue
			end
		
			---@type string
			local uid = res["uid"]
		
			if res["error_code"] == nil then
				local slot = requests[uid]
				doneUids[uid] = {
					["result"] = "SUCCESS",
					["slot"] = slot
				}
				
				-- 이미 백엔드 서버에서 캐릭터가 제거 되었음으로
				-- 굳이 데이터 스토리지에서 제거할 필요는 없다.
			else
				doneUids[uid] = {
					["result"] = res["error_code"]
				}
			end
		end
		
		for uid, slot in pairs(requests) do
			if doneUids[uid] == nil then
				self:DeleteCharacterFailure(_ErrorLogic.USER_DELETE_CHARACTER_UNKNOWN_ERROR, uid)
			else
				local result = doneUids[uid]
				if result["result"] == nil then
					self:DeleteCharacterFailure(_ErrorLogic.USER_DELETE_CHARACTER_UNKNOWN_ERROR, uid)
				elseif result["result"] == "SUCCESS" then
					self:DeleteCharacterComplete(result["slot"], uid)
				else
					self:DeleteCharacterFailure(result["result"], uid)
				end
			end
		end
	end

	@ExecSpace("Client")
	method void CreateCharacterFailure(string errorCode)
		local localPlayer = _UserService.LocalPlayer
		local e = CreateCharacterFailureEvent()
		e.errorCode = errorCode
		localPlayer:SendEvent(e)
	end

	@ExecSpace("Client")
	method void CreateCharacterComplete(Character newCharacter)
		local localPlayer = _UserService.LocalPlayer
		local e = CreateCharacterCompleteEvent()
		e.newCharacter = newCharacter
		localPlayer:SendEvent(e)
	end

	@ExecSpace("Client")
	method void UserCharacterLoadComplete(table characters)
		local localPlayer = _UserService.LocalPlayer
		local e = UserCharacterLoadCompleteEvent()
		e.characters = characters
		localPlayer:SendEvent(e)
	end

	@ExecSpace("Client")
	method void DeleteCharacterFailure(string errorCode)
		local localPlayer = _UserService.LocalPlayer
		local e = DeleteCharacterFailureEvent()
		e.errorCode = errorCode
		localPlayer:SendEvent(e)
	end

	@ExecSpace("Client")
	method void DeleteCharacterComplete(integer slot)
		local localPlayer = _UserService.LocalPlayer
		local e = DeleteCharacterCompleteEvent()
		e.slot = slot
		localPlayer:SendEvent(e)
	end

	@ExecSpace("ServerOnly")
	@EventSender("Self")
	handler HandleCreateCharacterEvent(CreateCharacterEvent e)
		-- 이미 생성 요청 중
		if self.isDoingCreateCharacter then
			return
		end
		
		self.isDoingCreateCharacter = true
		local callback = function()
			self:OnRequestCreateCharacter()
		end
		_TimerService:SetTimerOnce(callback, _DefLogic.CreateCharacterRequestTimeSec)
	end

	@ExecSpace("ServerOnly")
	@EventSender("Self")
	handler HandleDeleteCharacterEvent(DeleteCharacterEvent e)
		-- 이미 삭제 요청 중
		if self.isDoingDeleteCharacter then
			return
		end
		
		self.isDoingDeleteCharacter = true
		local callback = function()
			self:OnRequestDeleteCharacter()
		end
		_TimerService:SetTimerOnce(callback, _DefLogic.DeleteCharacterRequestTimeSec)
	end

end