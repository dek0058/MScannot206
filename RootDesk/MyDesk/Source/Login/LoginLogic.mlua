---@description "로그인에 대한 처리 및 관리를 담당하는 로직입니다"
@Logic
script LoginLogic extends Logic
	
	---@description "로그인 API"
	readonly property string Api_Login = "login"

	---@description "로그인 요청 대기 시간"
	readonly property integer LoginRequestTimeSec = 2

	---@description "로그인 요청 최대 처리 개수"
	readonly property integer MaxLoginRequestPerFlush = 10
	
	@ExecSpace("ServerOnly")
	method void OnBeginPlay()
		-- 로그인 요청 대기열 초기화
		self._T["LoginRequestQueue"] = UserRequestQueue()
	end

	---@description "유저의 로그인 상태를 가져옵니다"
	@ExecSpace("ServerOnly")
	method void FetchLogin(string uid)
		---@type UserDataStorage
		local userDataStorage = _DataStorageService:GetUserDataStorage(uid)
		if userDataStorage == nil then
			_GameServerLogic:KickByServer(uid, "UserDataStorage를 찾을 수 없습니다", "WorldError")
			return
		end

		local task = {}
		task["event"] = _DefLogic.EventEnterMap
		task["callback"] = function()
			while(true) do
				local t = _GameServerLogic:DequeueTask("EnterMap")
				if t == nil or #t == 0 then
					break
				end

				local callbackFunc = t["callback"]
				if callbackFunc ~= nil then
					callbackFunc()
				end
			end
		end

		local callback = function(errorCode, _, data)
			if errorCode ~= 0 then
				_GameServerLogic:KickByServer(uid, "유저 데이터 로드에 실패했습니다 [uid:" .. uid .. "][errorcode:" .. errorCode .. "]", "WorldError")
				return
			end

			if task == nil then
				_GameServerLogic:KickByServer(uid, "task가 null입니다 [uid:" .. uid .. "]", "WorldError")
				return 
			end

			if task["callback"] == nil then
				_GameServerLogic:KickByServer(uid, "task의 callback이 null입니다 [uid:" .. uid .. "]", "WorldError")
				return 
			end

			if _UtilLogic:IsNilorEmptyString(data) then
				_GameServerLogic:KickByServer(uid, "유저 데이터가 비어있습니다 [uid:" .. uid .. "]", "WorldError")
				return
			end

			local user = UserData():FromJson(data)

			local needLogin = user.userEntity == nil
				or _UtilLogic:IsNilorEmptyString(user.token)
				or user.version ~= _DefLogic.Version
				
			if needLogin == false then
				_UserLogic:AddUser(user)
			end

			task["callback"]()
		end

		userDataStorage:GetAsync("user", callback)
		_GameServerLogic:EnqueueTask(task)
	end
	
	---@description "유저가 로그인 요청을 합니다"
	@ExecSpace("Server")
	method void RequestLogin(string uid)
		if uid ~= senderUserId then
			return
		end

		---@type UserRequestQueue
		local queue = self._T["LoginRequestQueue"]
		if queue == nil then
			error("LoginRequestQueue가 없습니다")
			return
		end

		if queue:IsExists(uid) == true then
			local e = LoginEvent()
			e.errorCode = _ErrorLogic.LOGIN_ALREADY_REQUEST
			_UserProxy:SendEventToLocalPlayer(e, uid)
			return
		end

		local ur = UserRequest()
		ur.uid = uid

		queue:AddRequest(ur)

		self:OnReserveLogin()
	end

	---@description "요청받은 로그인을 처리합니다"
	@ExecSpace("ServerOnly")
	method void OnReserveLogin()
		if self._T["LoginTimerId"] ~= nil then
			return
		end

		local callback = function()
			self:OnRequestLogin()
			self._T["LoginTimerId"] = nil

			---@type UserRequestQueue
			local queue = self._T["LoginRequestQueue"]

			if queue == nil then
				return
			end

			if queue:IsEmpty() == true then
				return
			end

			self:OnReserveLogin()
		end

		local timerId = _TimerService:SetTimerOnce(callback, self.LoginRequestTimeSec)
		if timerId == 0 then
			log_error("로그인 요청 타이머 설정에 실패했습니다")

			--- 3초 대기 후 재시도
			_TimerService:SetTimerOnce(function()
				self:OnReserveLogin()
			end, 3.0)
			return
		end

		self._T["LoginTimerId"] = timerId
	end
	
	---@description "로그인 요청을 전송하며 응답받은 결과를 처리합니다"
	@ExecSpace("ServerOnly")
	method void OnRequestLogin()
		---@type UserRequestQueue
		local queue = self._T["LoginRequestQueue"]

		if queue == nil then
			log_error("LoginRequestQueue가 없습니다")
			return
		end

		if queue:IsEmpty() == true then
			return
		end

		local requests = queue:PullRequests(self.MaxLoginRequestPerFlush)

		local content = {
			["uids"] = {},
		}

		local req = LoginRequest()

		for _, r in ipairs(requests) do
			table.insert(content["uids"], r.uid)
			table.insert(req.uids, r.uid)
		end

		content["body"] = req:ToJson()

		local callback = function(response, request)
			---@type table<string>
			local uids = request["uids"]
			if uids == nil then
				return
			end

			local res = LoginResponse():FromJson(response)
			local passedUids = {}
			
			-- 성공한 uid들에 대해 데이터 저장 및 로그인 완료 전송
			for _, r in ipairs(res.successes) do
				if r.userEntity == nil then
					continue
				end

				if _UtilLogic:IsNilorEmptyString(r.userEntity.uid) == true then
					continue
				end

				local userDataStorage = _DataStorageService:GetUserDataStorage(r.userEntity.uid)
				if userDataStorage == nil then
					_GameServerLogic:KickByServer(r.userEntity.uid, "UserDataStorage를 찾을 수 없습니다", "WorldError")
					continue
				end

				local userData = UserData()
				userData.userEntity = r.userEntity
				userData.token = r.token
				userData.version = _DefLogic.Version
				
				userDataStorage:SetAsync(_UserLogic.Key_User, userData:ToJson(), function (errorCode, _)
					if errorCode ~= 0 then
						log_error("유저 데이터 저장에 실패했습니다 [uid" .. r.userEntity.uid .. "][errorcode:" .. errorCode .. "]")
						local e = LoginEvent()
						e.errorCode = _ErrorLogic.USER_DATA_STORAGE_WRITE_ERROR
						_UserProxy:SendEventToLocalPlayer(e, r.userEntity.uid)	
						return
					end

					_UserLogic:AddUser(userData)
					_UserProxy:SendEventToLocalPlayer(LoginEvent(), userData.userEntity.uid)
				end)

				passedUids[userData.userEntity.uid] = true
			end

			-- 실패한 uid들에 대해 오류 전송
			for _, r in ipairs(res.failures) do
				if _UtilLogic:IsNilorEmptyString(r.uid) == true then
					continue
				end

				local e = LoginEvent()
				e.errorCode = r.errorCode
				_UserProxy:SendEventToLocalPlayer(e, r.uid)
			end

			-- 처리되지 않은 uid들에 대해 알 수 없는 오류 전송
			for _, uid in pairs(uids) do
				if passedUids[uid] == true then
					continue
				end

				local e = LoginEvent()
				e.errorCode = _ErrorLogic.LOGIN_UNKNOWN_ERROR
				_UserProxy:SendEventToLocalPlayer(e, uid)
			end
		end

		local errorCallback = function (request)
			local uids = request["uids"]
			if uids == nil then
				return
			end

			for _, uid in pairs(uids) do
				local e = LoginEvent()
				e.errorCode = _ErrorLogic.LOGIN_UNABLE
				_UserProxy:SendEventToLocalPlayer(e, uid)
			end
		end

		_BackendLogic:PushRequest(_BackendLogic:CreateRequest(self.Api_Login, content, callback, errorCallback))
	end
	
end