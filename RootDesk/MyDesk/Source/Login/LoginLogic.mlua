@Logic
script LoginLogic extends Logic
	
	---@description "로그인 요청 대기 시간"
	readonly property integer LoginRequestTimeSec = 2

	---@description "로그인 요청 최대 처리 개수"
	readonly property integer MaxLoginRequestPerFlush = 10
	
	@ExecSpace("ServerOnly")
	method void OnBeginPlay()
		-- 로그인 요청 대기열 초기화
		self._T["LoginRequestQueue"] = UserRequestQueue()
	end

	---@description "유저의 로그인 상태를 가져옵니다."
	@ExecSpace("ServerOnly")
	method void FetchLogin(string uid)
		---@type UserDataStorage
		local userDataStorage = _DataStorageService:GetUserDataStorage(uid)
		if userDataStorage == nil then
			_GameServerLogic:KickByServer(uid, "UserDataStorage를 찾을 수 없습니다: ", "WorldError")
			return
		end

		local task = {}
		task["event"] = _DefLogic.EventEnterMap
		task["callback"] = function()
			while(true) do
				local t = _GameServerLogic:DequeueTask("EnterMap")
				if t == nil or #t == 0 then
					break
				end

				local callbackFunc = t["callback"]
				if callbackFunc ~= nil then
					callbackFunc()
				end
			end
		end

		local callback = function(errorCode, _, data)
			if errorCode ~= 0 then
				_GameServerLogic:KickByServer(uid, "유저 데이터 로드에 실패했습니다 [uid:" .. uid .. "][errorcode:" .. errorCode .. "]", "WorldError")
				return
			end

			if task == nil then
				_GameServerLogic:KickByServer(uid, "task가 null입니다 [uid:" .. uid .. "]", "WorldError")
				return 
			end

			if task["callback"] == nil then
				_GameServerLogic:KickByServer(uid, "task의 callback이 null입니다 [uid:" .. uid .. "]", "WorldError")
				return 
			end

			if _UtilLogic:IsNilorEmptyString(data) then
				_GameServerLogic:KickByServer(uid, "유저 데이터가 비어있습니다 [uid:" .. uid .. "]", "WorldError")
				return
			end

			local user = _HttpService:JSONDecode(data)
			if user == nil then
				_GameServerLogic:KickByServer(uid, "유저 데이터 디코드에 실패했습니다 [uid:" .. uid .. "]", "WorldError")
				return
			end

			local needLogin = user["user_entity"] == nil
			or user["token"] == nil
			or _UtilLogic:IsNilorEmptyString(user["token"])
			or user["version"] == nil
			or user["version"] ~= _DefLogic.Version

			if needLogin == false then
				_UserLogic:AddUser(user)
			end

			task["callback"]()
		end

		userDataStorage:GetAsync("user", callback)
		_GameServerLogic:EnqueueTask(task)
	end
	
	---@description "유저가 로그인 요청을 합니다."
	@ExecSpace("Server")
	method void RequestLogin(string uid)
		if uid ~= senderUserId then
			return
		end

		---@type UserRequestQueue
		local loginRequestQueue = self._T["LoginRequestQueue"]
		if loginRequestQueue == nil then
			error("LoginRequestQueue가 없습니다.")
			return
		end

		if loginRequestQueue:IsExists(uid) == true then
			local e = LoginEvent()
			e.errorCode = _ErrorLogic.LOGIN_ALREADY_REQUEST
			_UserProxy:SendEventToLocalPlayer(e, uid)
			return
		end

		local request = UserRequest()
		request.uid = uid

		loginRequestQueue:AddRequest(request)

		self:OnReserveLogin()
	end

	---@description "요청받은 로그인을 처리합니다."
	@ExecSpace("ServerOnly")
	method void OnReserveLogin()
		if self._T["LoginTimerId"] ~= nil then
			return
		end

		local callback = function()
			self:OnRequestLogin()
			self._T["LoginTimerId"] = nil

			---@type UserRequestQueue
			local loginRequestQueue = self._T["LoginRequestQueue"]

			if loginRequestQueue == nil then
				return
			end

			if loginRequestQueue:IsEmpty() == true then
				return
			end

			self:OnReserveLogin()
		end

		local timerId = _TimerService:SetTimerOnce(callback, self.LoginRequestTimeSec)
		if timerId == 0 then
			log_error("로그인 요청 타이머 설정에 실패했습니다.")

			--- 3초 대기 후 재시도
			_TimerService:SetTimerOnce(function()
				self:OnReserveLogin()
			end, 3.0)
			return
		end

		self._T["LoginTimerId"] = timerId
	end
	
	---@description "로그인 요청을 전송하며 응답받은 결과를 처리합니다."
	@ExecSpace("ServerOnly")
	method void OnRequestLogin()
		---@type UserRequestQueue
		local loginRequestQueue = self._T["LoginRequestQueue"]

		if loginRequestQueue == nil then
			log_error("LoginRequestQueue가 없습니다.")
			return
		end

		if loginRequestQueue:IsEmpty() == true then
			return
		end

		local requests = loginRequestQueue:PullRequests(self.MaxLoginRequestPerFlush)

		local content = {
			["uids"] = {},
			["body"] = {
				["uids"] = {}
			},
		}

		for _, r in pairs(requests) do
			table.insert(content["uids"], r.uid)
		end
		content["body"]["uids"] = content["uids"]

		local callback = function(response, request)
			---@type table<string>
			local uids = request["uids"]
			if uids == nil then
				return
			end

			local success_uids = response["success_uids"]
			local fail_uids = response["fail_uids"]

			local passedUids = {}
			
			-- 성공한 uid들에 대해 데이터 저장 및 로그인 완료 전송
			if success_uids ~= nil then
				for i, data in ipairs(success_uids) do
					---@type table
					local user_entity = data["user_entity"]

					---@type string
					local token = data["token"]

					if user_entity == nil or token == nil then
						continue
					end

					---@type string
					local uid = user_entity["uid"]

					---@type table
					local characters = user_entity["characters"]

					if uid == nil or characters == nil then
						continue
					end

					---@type UserDataStorage
					local userDataStorage = _DataStorageService:GetUserDataStorage(uid)
					if userDataStorage == nil then
						error("UserDataStorage를 찾을 수 없습니다: " .. uid)
						continue
					end

					data["version"] = _DefLogic.Version
					local saveData = _HttpService:JSONEncode(data)
					userDataStorage:SetAsync("user", saveData, function(errorCode, key)
						if errorCode ~= 0 then
							log_error("유저 데이터 저장에 실패했습니다 [uid" .. uid .. "][errorcode:" .. errorCode .. "]")
							local e = LoginEvent()
							e.errorCode = _ErrorLogic.USER_DATA_STORAGE_WRITE_ERROR
							_UserProxy:SendEventToLocalPlayer(e, uid)	
							return
						end

						_UserLogic:AddUser(data)
						_UserProxy:SendEventToLocalPlayer(LoginEvent(), uid)	
					end)

					passedUids[uid] = true
				end
			end

			-- 실패한 uid들에 대해 오류 전송
			if fail_uids ~= nil then
				for i, data in ipairs(fail_uids) do
					---@type string
					local uid = data["uid"]

					---@type string
					local errorCode = data["error_code"]

					if uid == nil or errorCode == nil then
						continue
					end

					if passedUids[uid] == true then
						continue
					end

					local e = LoginEvent()
					e.errorCode = errorCode
					_UserProxy:SendEventToLocalPlayer(e, uid)
				end
			end

			-- 처리되지 않은 uid들에 대해 알 수 없는 오류 전송
			for _, uid in pairs(uids) do
				if passedUids[uid] == true then
					continue
				end

				local e = LoginEvent()
				e.errorCode = _ErrorLogic.LOGIN_UNKNOWN_ERROR
				_UserProxy:SendEventToLocalPlayer(e, uid)
			end
		end

		local errorCallback = function (request)
			local uids = request["uids"]
			if uids == nil then
				return
			end

			for _, uid in pairs(uids) do
				local e = LoginEvent()
				e.errorCode = _ErrorLogic.LOGIN_UNABLE
				_UserProxy:SendEventToLocalPlayer(e, uid)
			end
		end

		_BackendLogic:PushRequest(_BackendLogic:CreateRequest("login", content, callback, errorCallback))
	end
	
end