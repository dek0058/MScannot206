@Logic
script LoginLogic extends Logic
	
	property integer loginTimerDelay = 1
	
	property boolean isDoingLogin = false
	
	property integer pendingLoginUserIdsIndex = 0
	property integer requestLoginUserIdsIndex = 0
	property table loginUserIds = {}

	property table userTokens = {}
	
	method void OnBeginPlay()
		if self:IsServer() == true then
			self:OnServerInit()
		end	
	end

	@ExecSpace("Server")
	method void OnServerInit()
		_HttpService.httpEnabled = true
	end

	@ExecSpace("Server")
	method void ValidateLogin(string userId, Entity sender)
		if senderUserId ~= userId then
			log("다른 사용자가 로그인 확인 시도를 하였습니다: " .. senderUserId .. " != " .. userId)
			_UserService:KickUser(userId, KickReason.ETC)
			return
		end

		---@type UserDataStorage
		local UserDataStorage = _DataStorageService:GetUserDataStorage(userId)
		if UserDataStorage == nil then
			error("UserDataStorage를 찾을 수 없습니다: " .. userId)
			_UserService:KickUser(userId, KickReason.ETC)
			return
		end
		
		local callback = function(success, data)
			if success ~= true then
				sender:SendEvent(NeedLoginEvent())
			else
				local session = _HttpService:JSONDecode(data)
				if session["version"] == nil or session["version"] ~= _DefLogic.Version then
					sender:SendEvent(NeedLoginEvent())
				else
					self.userTokens[userId] = session["token"]
					sender:SendEvent(LoggedinEvent())
				end
			end
		end
		UserDataStorage:GetAsync("token", callback)
	end
	
	@ExecSpace("Server")
	method void RequestLogin(string userId)
		if senderUserId ~= userId then
			error("다른 사용자가 로그인 시도를 하였습니다: " .. senderUserId .. " != " .. userId)
			self:LoginFailure("LOGIN_INVALID_UID", senderUserId)
			return
		end
		
		local beginIndex = self.requestLoginUserIdsIndex + 1
		local endIndex = self.pendingLoginUserIdsIndex
		
		for i = beginIndex, endIndex do
			if self.loginUserIds[i] == userId then
				-- 이미 로그인 요청을 한 유저
				self:LoginFailure("LOGIN_ALREADY_REQUEST", senderUserId)
				return
			end
		end
		
		self.pendingLoginUserIdsIndex = self.pendingLoginUserIdsIndex + 1
		self.loginUserIds[self.pendingLoginUserIdsIndex] = userId
		
		self:SendEvent(LoginEvent())
	end
	
	@ExecSpace("ServerOnly")
	method void OnRequestLogin()
		self:OnRequestLogin_Doing()
		self.isDoingLogin = false
		
		-- 추가적인 로그인 요청이 있었는지 확인
		if self.requestLoginUserIdsIndex < self.pendingLoginUserIdsIndex then
			self:SendEvent(LoginEvent())
		end
	end
	
	@ExecSpace("ServerOnly")
	method void OnRequestLogin_Doing()
		local beginIndex = self.requestLoginUserIdsIndex + 1
		local endIndex = self.pendingLoginUserIdsIndex
		
		local headers = {
			["Content-Type"] = "application/json"
		}
		
		local content = {
			["uids"] = {}
		}
		
		for i = beginIndex, endIndex do
			table.insert(content["uids"], self.loginUserIds[i])
		end
		
		local contentJson = _HttpService:JSONEncode(content)
		
		local requestTime = DateTime.UtcNow
		local response = _HttpService:RequestAndWait(
			_DefLogic.BackendUrl .. "/login",
			"POST", contentJson, headers
		)
		self.requestLoginUserIdsIndex = endIndex

		self:OnResponseLogin(response, content["uids"])
		
		local responseTime = DateTime.UtcNow
		local diff = TimeSpan(tostring(responseTime - requestTime))
		
		-- 추가 요청이 존재하고 로그인 Delay 시간을 초과했다면 즉시 재실행
		if self.requestLoginUserIdsIndex < self.pendingLoginUserIdsIndex then
			if diff.Seconds >= self.loginTimerDelay then
				self:OnRequestLogin_Doing()
			end
		end
	end
	
	@ExecSpace("ServerOnly")
	method void OnResponseLogin(string response, table requestUids)
		if response == "" then
			for i, uid in ipairs(requestUids) do
				self:LoginFailure("LOGIN_UNABLE", uid)
			end
			return
		end
		
		local content = _HttpService:JSONDecode(response)
		
		local successUids = content["success_uids"]
		local failUids = content["fail_uids"]

		---@type table
		local doneUids = {}

		if failUids ~= nil then
			for i, entry in ipairs(failUids) do
				if entry == nil then
					continue
				end

				if entry["uid"] == nil then
					continue
				end

				if entry["error_code"] == nil then
					---@type string
					local uid = entry["uid"]
					doneUids[uid] = _ErrorLogic.LOGIN_UNKNOWN_ERROR
					continue
				end

				---@type string
				local uid = entry["uid"]
				---@type string
				local errorCode = entry["error_code"]
				doneUids[uid] = errorCode
			end
		end
		
		if successUids ~= nil then
			for i, entry in ipairs(successUids) do
				if entry == nil then
					continue
				end

				if entry["user_entity"] == nil then
					continue
				end

				---@type table
				local userEntity = entry["user_entity"]
				if userEntity["uid"] == nil then
					continue
				end

				---@type string
				local uid = userEntity["uid"]
				
				if entry["token"] == nil then
					doneUids[uid] = _ErrorLogic.LOGIN_SESSION_CREATE_ERROR
					continue
				end

				---@type string
				local token = userEntity["token"]

				self.userTokens[uid] = token
				doneUids[uid] = "SUCCESS"
			end
		end
		

		for i, uid in ipairs(requestUids) do
			local result = doneUids[uid]
			if result == nil then
				self:LoginFailure(_ErrorLogic.LOGIN_UNKNOWN_ERROR, uid)
			elseif result == "SUCCESS" then
				self:LoginComplete(uid)
			else
				self:LoginFailure(result, uid)
			end
		end
	end
	
	@ExecSpace("Client")
	method void LoginComplete()
		local localPlayer = _UserService.LocalPlayer
		localPlayer:SendEvent(LoginCompleteEvent())
	end
	
	@ExecSpace("Client")
	method void LoginFailure(string errorCode)
		local localPlayer = _UserService.LocalPlayer
		local e = LoginFailureEvent()
		e.errorCode = errorCode
		localPlayer:SendEvent(e)
	end
	
	@ExecSpace("ServerOnly")
	@EventSender("Self")
	handler HandleLoginEvent(LoginEvent event)
		-- 이미 로그인 요청 중
		if self.isDoingLogin then
			return
		end
		
		self.isDoingLogin = true
		local callback = function()
			self:OnRequestLogin()
		end
		_TimerService:SetTimerOnce(callback, self.loginTimerDelay)
	end
	
end