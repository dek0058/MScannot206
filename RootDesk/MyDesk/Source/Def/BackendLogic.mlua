---@description "백엔드 서버에 대한 설정 및 공통 메서드가 정의 되어 있는 로직입니다."
@Logic
script BackendLogic extends Logic
	---@description "백엔드 서버 URL"
	property string Url = "http://localhost"
	
	---@description "백엔드 서버에 요청을 주기적으로 전송하는 시간 간격 (초)"
	readonly property number UpdateTimeSec = 1.5

	---@description "한 번에 전송할 최대 요청 개수"
	readonly property integer MaxRequestPerFlush = 20

	-- HTTP API 요청 제한 문서 참고
	-- https://maplestoryworlds-creators.nexon.com/ko/apiReference/Services/HttpService
	
	-- Update 2025-08-27 PM 04:56
	-- 분당 최대 120회의 Http요청으로 제한합니다. 초과할 경우 30초간 HttpService요청이 불가능합니다.
	-- 각 요청당 Timeout은 30초입니다.
	-- Tls1.2 이상만 지원합니다. Tls1.0, Tls1.1의 경우 통신 시도를 하면 오류가 발생합니다.
	-- 80, 443을 제외한 1024 미만 포트에서는 사용이 제한됩니다. (＜1024) MSW 임베디드 서버 지정 대역은 30011 ~ 30019입니다.
	-- 응답 버퍼는 10MB로 제한합니다.
	
	@ExecSpace("ServerOnly")
	method void OnBeginPlay()
		_HttpService.httpEnabled = true
		
		local url = "http://localhost:8080"
		-- not committed code
		-- 백엔드 서버 URL 노출이 되지 않도록 관리 필요함
		if Environment:IsPublishedPlay() == true then
			url = ""
			if _UtilLogic:IsNilorEmptyString(url) == true then
				log_error("퍼블리싱 환경에서 BackendUrl이 설정되지 않았습니다.")
			end
		end
		-- end
		self.Url = url .. "/api/v1"
		
		-- 공통 헤더 정보 설정
		self._T["headers"] = {
			["Content-Type"] = "application/json"
		}

		-- 요청 저장소 초기화
		self._T["requests"] = {}
	end

	---@description "백엔드 서버에 대한 요청 처리를 예약합니다."
	@ExecSpace("ServerOnly")
	method void OnReserve()
		if self._T["UpdateTimerId"] ~= nil then
			return
		end

		local callback = function ()
			self:Flush()
			self._T["UpdateTimerId"] = nil
			self:OnReserve()
		end

		local timerId = _TimerService:SetTimerOnce(callback, self.UpdateTimeSec)
		if timerId == 0 then
			log_error("업데이트 타이머 설정에 실패했습니다.")

			--- 3초 대기 후 재시도
			_TimerService:SetTimerOnce(function()
				self:OnReserve()
			end, 3.0)
			return
		end

		self._T["UpdateTimerId"] = timerId
	end
	
	---@description "공통 헤더 정보를 반환합니다."
	@ExecSpace("ServerOnly")
	method table GetHeaders()
		if self._T["headers"] == nil then
			return {}
		end
		return self._T["headers"]
	end
	
	---@description "백엔드 서버에 보낼 HTTP 요청을 생성합니다."
	@ExecSpace("ServerOnly")
	method HttpRequest CreateRequest(string api, table<string, any> content, any callback, any errorCallback)
		local request = HttpRequest()
		request.api = api
		request.content = content
		request.callback = callback
		request.errorCallback = errorCallback
		return request
	end

	---@description "백엔드 서버에 요청을 저장합니다."
	@ExecSpace("ServerOnly")
	method void PushRequest(HttpRequest request)
		if request == nil then
			return
		end

		---@type table<HttpRequest>
		local requests = self._T["requests"]
		if requests == nil then
			return
		end

		table.insert(requests, request)

		self:OnReserve()
	end

	---@description "백엔드 서버에 저장된 요청을 모두 처리합니다."
	@ExecSpace("ServerOnly")
	method void Flush()
		---@type table<HttpRequest>
		local requests = self._T["requests"]

		if requests == nil then
			return
		end

		if #requests == 0 then
			return
		end

		---@type table<string, string>
		local headers = self:GetHeaders()
		local contents = {}

		---@type table<string, HttpRequest>
		local sendRequests = {}

		for i = 1, self.MaxRequestPerFlush do
			---@type HttpRequest
			local request = table.remove(requests, 1)
			if request == nil then
				break
			end

			for _, value in pairs(request.headers) do
				table.insert(headers, value)
			end

			---@type string
			local api = request.api
			if _UtilLogic:IsNilorEmptyString(api) == true then
				log_error("request의 api가 비어있습니다.")
				continue
			end

			---@type table
			local body = request.content["body"]
			if body == nil then
				body = {}
			end

			local key = request.api .. "?" .. tostring(i)
			sendRequests[key] = request
			contents[i] = {
				["dto"] = {
					["api"] = key,
					["body"] = _HttpService:JSONEncode(body)
				}
			}
		end

		local response = _HttpService:RequestAndWait(
			self.Url .. "/batch",
			"POST",
			_HttpService:JSONEncode(contents),
			headers
		)

		if _UtilLogic:IsNilorEmptyString(response) == true then
			log_error("백엔드 서버로부터 응답이 없습니다.")
			for _, request in pairs(sendRequests) do
				self:SendError(request)
			end
			return
		end

		---@type table<string, any>
		local passedApiKey = {}

		local data = _HttpService:JSONDecode(response)

		---@type table
		local dto = data["dto"]
		
		if dto == nil then
			for _, request in pairs(sendRequests) do
				self:SendError(request)
			end
			return
		end

		for _, item in ipairs(dto) do
			if item["api"] == nil then
				continue
			end

			local key = item["api"]
			if _UtilLogic:IsNilorEmptyString(key) == true then
				continue
			end

			---@type HttpRequest
			local request = sendRequests[key]
			if request == nil then
				continue
			end

			passedApiKey[key] = true

			---@type string
			local body = item["body"]
			local responseData = {}
			if _UtilLogic:IsNilorEmptyString(body) == false then
				responseData = _HttpService:JSONDecode(body)
			end

			if request.callback ~= nil then
				request.callback(responseData, request.content)
			end
		end

		-- 처리되지 않은 요청에 대해 에러 콜백 호출
		for key, request in pairs(sendRequests) do
			if passedApiKey[key] == nil then
				self:SendError(request)
			end
		end
	end

	---@description "백엔드 서버 요청에 대한 에러 콜백을 호출합니다."
	@ExecSpace("ServerOnly")
	method void SendError(HttpRequest request)
		if request == nil then
			return
		end

		if request.errorCallback ~= nil then
			request.errorCallback(request.content)
		end
	end
	
end