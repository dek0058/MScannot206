@Logic
script TweenUtility extends Logic

	method void OnBeginPlay()
		self._T[EaseType.Linear] = function(value) return self:Linear(value) end
		self._T[EaseType.QuadEaseOut] = function(value) return self:QuadEaseOut(value) end
		self._T[EaseType.QuadEaseIn] = function(value) return self:QuadEaseIn(value) end
		self._T[EaseType.QuadEaseInOut] = function(value) return self:QuadEaseInOut(value) end
		self._T[EaseType.QuadEaseOutIn] = function(value) return self:QuadEaseOutIn(value) end
		self._T[EaseType.ExpoEaseOut] = function(value) return self:ExpoEaseOut(value) end
		self._T[EaseType.ExpoEaseIn] = function(value) return self:ExpoEaseIn(value) end
		self._T[EaseType.ExpoEaseInOut] = function(value) return self:ExpoEaseInOut(value) end
		self._T[EaseType.ExpoEaseOutIn] = function(value) return self:ExpoEaseOutIn(value) end
		self._T[EaseType.CubicEaseOut] = function(value) return self:CubicEaseOut(value) end
		self._T[EaseType.CubicEaseIn] = function(value) return self:CubicEaseIn(value) end
		self._T[EaseType.CubicEaseInOut] = function(value) return self:CubicEaseInOut(value) end
		self._T[EaseType.CubicEaseOutIn] = function(value) return self:CubicEaseOutIn(value) end
		self._T[EaseType.QuartEaseOut] = function(value) return self:QuartEaseOut(value) end
		self._T[EaseType.QuartEaseIn] = function(value) return self:QuartEaseIn(value) end
		self._T[EaseType.QuartEaseInOut] = function(value) return self:QuartEaseInOut(value) end
		self._T[EaseType.QuartEaseOutIn] = function(value) return self:QuartEaseOutIn(value) end
		self._T[EaseType.QuintEaseOut] = function(value) return self:QuintEaseOut(value) end
		self._T[EaseType.QuintEaseIn] = function(value) return self:QuintEaseIn(value) end
		self._T[EaseType.QuintEaseInOut] = function(value) return self:QuintEaseInOut(value) end
		self._T[EaseType.QuintEaseOutIn] = function(value) return self:QuintEaseOutIn(value) end
		self._T[EaseType.CircEaseOut] = function(value) return self:CircEaseOut(value) end
		self._T[EaseType.CircEaseIn] = function(value) return self:CircEaseIn(value) end
		self._T[EaseType.CircEaseInOut] = function(value) return self:CircEaseInOut(value) end
		self._T[EaseType.CircEaseOutIn] = function(value) return self:CircEaseOutIn(value) end
		self._T[EaseType.SineEaseOut] = function(value) return self:SineEaseOut(value) end
		self._T[EaseType.SineEaseIn] = function(value) return self:SineEaseIn(value) end
		self._T[EaseType.SineEaseInOut] = function(value) return self:SineEaseInOut(value) end
		self._T[EaseType.SineEaseOutIn] = function(value) return self:SineEaseOutIn(value) end
		self._T[EaseType.ElasticEaseOut] = function(value) return self:ElasticEaseOut(value) end
		self._T[EaseType.ElasticEaseIn] = function(value) return self:ElasticEaseIn(value) end
		self._T[EaseType.ElasticEaseInOut] = function(value) return self:ElasticEaseInOut(value) end
		self._T[EaseType.ElasticEaseOutIn] = function(value) return self:ElasticEaseOutIn(value) end
		self._T[EaseType.BounceEaseOut] = function(value) return self:BounceEaseOut(value) end
		self._T[EaseType.BounceEaseIn] = function(value) return self:BounceEaseIn(value) end
		self._T[EaseType.BounceEaseInOut] = function(value) return self:BounceEaseInOut(value) end
		self._T[EaseType.BounceEaseOutIn] = function(value) return self:BounceEaseOutIn(value) end
		self._T[EaseType.BackEaseOut] = function(value) return self:BackEaseOut(value) end
		self._T[EaseType.BackEaseIn] = function(value) return self:BackEaseIn(value) end
		self._T[EaseType.BackEaseInOut] = function(value) return self:BackEaseInOut(value) end
		self._T[EaseType.BackEaseOutIn] = function(value) return self:BackEaseOutIn(value) end
	end

	method number GetValue(number easeType, number value)
		local callback = self._T[EaseType.CastFrom(easeType)]
		if callback ~= nil then
			return callback(value)
		else
			return value
		end
	end

	method number GetValueByString(string easeType, number value)
		local callback = self._T[EaseType.CastFrom(easeType)]
		if callback ~= nil then
			return callback(value)
		else
			return value
		end
	end

	method number Linear(number t)
		return t
	end

	method number QuadEaseOut(number t)
		return t * (2 - t)
	end

	method number QuadEaseIn(number t)
		return t * t
	end

	method number QuadEaseInOut(number t)
		if t < 0.5 then
			return 2 * t * t
		else
			return -1 + (4 - 2 * t) * t
		end
	end

	method number QuadEaseOutIn(number t)
		if t < 0.5 then
			return self:QuadEaseOut(t * 2) / 2
		else
			return self:QuadEaseIn((t - 0.5) * 2) / 2 + 0.5
		end
	end

	method number ExpoEaseOut(number t)
		if t == 1 then
			return 1
		else
			return 1 - math.pow(2, -10 * t)
		end
	end

	method number ExpoEaseIn(number t)
		if t == 0 then
			return 0
		else
			return math.pow(2, 10 * (t - 1))
		end
	end

	method number ExpoEaseInOut(number t)
		if t == 0 then
			return 0
		end
		if t == 1 then
			return 1
		end
		if t < 0.5 then
			return math.pow(2, 20 * t - 10) / 2
		else
			return (2 - math.pow(2, -20 * t + 10)) / 2
		end
	end

	method number ExpoEaseOutIn(number t)
		if t < 0.5 then
			return self:ExpoEaseOut(t * 2) / 2
		else
			return self:ExpoEaseIn((t - 0.5) * 2) / 2 + 0.5
		end
	end

	method number CubicEaseOut(number t)
		t -= 1
		return t * t * t + 1
	end

	method number CubicEaseIn(number t)
		return t * t * t
	end

	method number CubicEaseInOut(number t)
		if t < 0.5 then
			return 4 * t * t * t
		else
			return (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
		end
	end

	method number CubicEaseOutIn(number t)
		if t < 0.5 then
			return self:CubicEaseOut(t * 2) / 2
		else
			return self:CubicEaseIn((t - 0.5) * 2) / 2 + 0.5
		end
	end

	method number QuartEaseOut(number t)
		t -= 1
		return 1 - t * t * t * t
	end

	method number QuartEaseIn(number t)
		return t * t * t * t
	end

	method number QuartEaseInOut(number t)
		if t < 0.5 then
			return 8 * t * t * t * t
		else
			t -= 1
			return 1 - 8 * t * t * t * t
		end
	end

	method number QuartEaseOutIn(number t)
		if t < 0.5 then
			return self:QuartEaseOut(t * 2) / 2
		else
			return self:QuartEaseIn((t - 0.5) * 2) / 2 + 0.5
		end
	end

	method number QuintEaseOut(number t)
		t -= 1
		return 1 + t * t * t * t * t
	end

	method number QuintEaseIn(number t)
		return t * t * t * t * t
	end

	method number QuintEaseInOut(number t)
		if t < 0.5 then
			return 16 * t * t * t * t * t
		else
			t -= 1
			return 1 + 16 * t * t * t * t * t
		end
	end

	method number QuintEaseOutIn(number t)
		if t < 0.5 then
			return self:QuintEaseOut(t * 2) / 2
		else
			return self:QuintEaseIn((t - 0.5) * 2) / 2 + 0.5
		end
	end

	method number CircEaseOut(number t)
		t -= 1
		return math.sqrt(1 - t * t)
	end

	method number CircEaseIn(number t)
		return 1 - math.sqrt(1 - t * t)
	end

	method number CircEaseInOut(number t)
		if t < 0.5 then
			return (1 - math.sqrt(1 - 4 * t * t)) / 2
		else
			t = t * 2 - 2
			return (math.sqrt(1 - t * t) + 1) / 2
		end
	end

	method number CircEaseOutIn(number t)
		if t < 0.5 then
			return self:CircEaseOut(t * 2) / 2
		else
			return self:CircEaseIn((t - 0.5) * 2) / 2 + 0.5
		end
	end

	method number SineEaseOut(number t)
		return math.sin((t * math.pi) / 2)
	end

	method number SineEaseIn(number t)
		return 1 - math.cos((t * math.pi) / 2)
	end

	method number SineEaseInOut(number t)
		return -(math.cos(math.pi * t) - 1) / 2
	end

	method number SineEaseOutIn(number t)
		if t < 0.5 then
			return self:SineEaseOut(t * 2) / 2
		else
			return self:SineEaseIn((t - 0.5) * 2) / 2 + 0.5
		end
	end

	method number ElasticEaseOut(number t)
		local c4 = (2 * math.pi) / 3
		if t == 0 then
			return 0
		end
		if t == 1 then
			return 1
		end
		return math.pow(2, -10 * t) * math.sin((t * 10 - 0.75) * c4) + 1
	end

	method number ElasticEaseIn(number t)
		local c4 = (2 * math.pi) / 3
		if t == 0 then
			return 0
		end
		if t == 1 then
			return 1
		end
		return -math.pow(2, 10 * t - 10) * math.sin((t * 10 - 10.75) * c4)
	end

	method number ElasticEaseInOut(number t)
		local c5 = (2 * math.pi) / 4.5
		if t == 0 then
			return 0
		end
		if t == 1 then
			return 1
		end
		if t < 0.5 then
			return -(math.pow(2, 20 * t - 10) * math.sin((20 * t - 11.125) * c5)) / 2
		end
		return (math.pow(2, -20 * t + 10) * math.sin((20 * t - 11.125) * c5)) / 2 + 1
	end

	method number ElasticEaseOutIn(number t)
		if t < 0.5 then
			return self:ElasticEaseOut(t * 2) / 2
		else
			return self:ElasticEaseIn((t - 0.5) * 2) / 2 + 0.5
		end
	end

	method number BounceEaseOut(number t)
		local n1 = 7.5625
		local d1 = 2.75
		if t < 1 / d1 then
			return n1 * t * t
		elseif t < 2 / d1 then
			t -= 1.5 / d1
			return n1 * t * t + 0.75
		elseif t < 2.5 / d1 then
			t -= 2.25 / d1
			return n1 * t * t + 0.9375
		else
			t -= 2.625 / d1
			return n1 * t * t + 0.984375
		end
	end

	method number BounceEaseIn(number t)
		return 1 - self:BounceEaseOut(1 - t)
	end

	method number BounceEaseInOut(number t)
		if t < 0.5 then
			return (1 - self:BounceEaseOut(1 - 2 * t)) / 2
		else
			return (1 + self:BounceEaseOut(2 * t - 1)) / 2
		end
	end

	method number BounceEaseOutIn(number t)
		if t < 0.5 then
			return self:BounceEaseOut(t * 2) / 2
		else
			return self:BounceEaseIn((t - 0.5) * 2) / 2 + 0.5
		end
	end

	method number BackEaseOut(number t)
		local c1 = 1.70158
		local c3 = c1 + 1
		return 1 + c3 * math.pow(t - 1, 3) + c1 * math.pow(t - 1, 2)
	end

	method number BackEaseIn(number t)
		local c1 = 1.70158
		local c3 = c1 + 1
		return c3 * t * t * t - c1 * t * t
	end

	method number BackEaseInOut(number t)
		local c1 = 1.70158
		local c2 = c1 * 1.525
		if t < 0.05 then
			return (math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2
		end
		return (math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2
	end

	method number BackEaseOutIn(number t)
		if t < 0.5 then
			return self:BackEaseOut(t * 2) / 2
		else
			return self:BackEaseIn((t - 0.5) * 2) / 2 + 0.5
		end
	end

end